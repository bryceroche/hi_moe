{"problem": "Problem:\n\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false\n\nExample 4:\nInput: s = \"([])\"\nOutput: true\n\n\nPlan:\n\n\nWrite a Python solution. Brief analysis (2-3 sentences), then code in ```python``` blocks.\nDo NOT use <think> tags. Output format example:\n\nThe approach uses X algorithm with O(n) complexity.\n\n```python\ndef solution():\n    # implementation\n```", "reasoning": "The approach uses a stack to track opening brackets and validate against closing brackets in O(n) time and space.", "solution": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    open_set = {'(', '{', '['}\n    for char in s:\n        if char in open_set:\n            stack.append(char)\n        else:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack", "domain": "python", "problem_id": "valid_parentheses", "source_file": "run-valid_parentheses-6098bc07.jsonl"}
{"problem": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all\noverlapping intervals, and return an array of the non-overlapping intervals\nthat cover all the intervals in the input.\n\nTo solve this problem, you should first sort the intervals by their start times.\nThen, iterate through the sorted intervals and merge overlapping ones.\nFinally, return the merged result.\n\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nConstraints:\n- 1 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= start_i <= end_i <= 10^4", "reasoning": "The approach sorts intervals by start time and merges overlapping intervals in a single pass. This ensures an O(n log n) time complexity due to sorting, followed by a linear scan.", "solution": "def merge(intervals):\n    if not intervals:\n        return []\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    result = [sorted_intervals[0]]\n    for current in sorted_intervals[1:]:\n        last = result[-1]\n        if current[0] <= last[1]:\n            merged_start = last[0]\n            merged_end = max(last[1], current[1])\n            result[-1] = [merged_start, merged_end]\n        else:\n            result.append(current)\n    return result", "domain": "python", "problem_id": "merge_intervals", "source_file": "run-merge_intervals-0b2cf305.jsonl"}
